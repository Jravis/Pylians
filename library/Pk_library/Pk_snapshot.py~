import numpy as np
import readsnap
import redshift_space_library as RSL
import MAS_library as MASL
import units_library as UL
from Pk import *
import sys,os

U = UL.units();  rho_crit = U.rho_crit
###############################################################################
# This routine computes the auto- and cross-power spectra of a Gadget snapshot
# in real or redshift-space. Can compute the total matter power spectrum or the
# auto- cross-power spectra of different particle types.
# If one only wants the total matter P(k), set particle_type=[-1]. If the P(k)
# of the different components is wanted set for instance particle_type=[0,1,4]
# snapshot_fname -----------> name of the Gadget snapshot
# dims ---------------------> Total number of cells is dims^3 to compute Pk
# particle_type ------------> compute Pk of those particles, e.g. [1,2]
# do_RSD -------------------> Pk in redshift-space (True) or real-space (False)
# axis ---------------------> axis along which move particles in redshift-space
# hydro --------------------> whether snapshot is hydro (True) or not (False)
# cpus ---------------------> Number of cpus to compute power spectra
def Pk_snapshot(snapshot_fname,dims,particle_type,do_RSD,axis,hydro,cpus):

    # read snapshot head and obtain BoxSize, Omega_m and Omega_L
    print '\nREADING SNAPSHOTS PROPERTIES'
    head     = readsnap.snapshot_header(snapshot_fname)
    BoxSize  = head.boxsize/1e3  #Mpc/h
    Nall     = head.nall
    Masses   = head.massarr*1e10 #Msun/h
    Omega_m  = head.omega_m
    Omega_l  = head.omega_l
    redshift = head.redshift
    Hubble   = 100.0*np.sqrt(Omega_m*(1.0+redshift)**3+Omega_l)  #km/s/(Mpc/h)
    h        = head.hubble
    z        = '%.3f'%redshift
    dims3    = dims**3

    # compute the values of Omega_cdm, Omega_nu, Omega_gas and Omega_s
    Omega_c = Masses[1]*Nall[1]/BoxSize**3/rho_crit
    Omega_n = Masses[2]*Nall[2]/BoxSize**3/rho_crit
    Omega_g, Omega_s = 0.0, 0.0
    if Nall[0]>0:
        if Masses[0]>0:  
            Omega_g = Masses[0]*Nall[0]/BoxSize**3/rho_crit
            Omega_s = Masses[4]*Nall[4]/BoxSize**3/rho_crit
        else:    
            # mass in Msun/h
            mass = readsnap.read_block(snapshot_fname,"MASS",parttype=0)*1e10 
            Omega_g = np.sum(mass,dtype=np.float64)/BoxSize**3/rho_crit
            mass = readsnap.read_block(snapshot_fname,"MASS",parttype=4)*1e10
            Omega_s = np.sum(mass,dtype=np.float64)/BoxSize**3/rho_crit
            del mass

    # some verbose
    print 'Omega_gas    = ',Omega_g
    print 'Omega_cdm    = ',Omega_c
    print 'Omega_nu     = ',Omega_n
    print 'Omega_star   = ',Omega_s
    print 'Omega_m      = ',Omega_g + Omega_c + Omega_n + Omega_s
    print 'Omega_m snap = ',Omega_m

    ######################################################################
    # for total matter just use all particles
    if particle_type==[-1]:

        print 'Computing total matter power spectrum...'
        
        # read the positions of all the particles
        pos = readsnap.read_block(snapshot_fname,"POS ",parttype=-1)/1e3 #Mpc/h
        print '%.3f < X [Mpc/h] < %.3f'%(np.min(pos[:,0]),np.max(pos[:,0]))
        print '%.3f < Y [Mpc/h] < %.3f'%(np.min(pos[:,1]),np.max(pos[:,1]))
        print '%.3f < Z [Mpc/h] < %.3f\n'%(np.min(pos[:,2]),np.max(pos[:,2]))

        if do_RSD:
            print 'moving particles to redshift-space'
            # read the velocities of all the particles
            vel = readsnap.read_block(snapshot_fname,"VEL ",parttype=-1) #km/s
            RSL.pos_redshift_space(pos,vel,BoxSize,Hubble,redshift,axis)
            del vel

        # read the masses of all the particles
        if not(hydro):
            Ntotal = np.sum(Nall,dtype=np.int64)#compute the number of particles
            M = np.zeros(Ntotal,dtype=np.float32) #define the mass array
            offset = 0
            for ptype in [0,1,2,3,4,5]:
                M[offset:offset+Nall[ptype]] = Masses[ptype]
                offset += Nall[ptype]
        else:
            M = readsnap.read_block(snapshot_fname,"MASS",parttype=-1)*1e10
            print '%.3e < M [Msun/h] < %.3e'%(np.min(M),np.max(M))
            print 'Omega_M = %.4f\n'\
                %(np.sum(M,dtype=np.float64)/rho_crit/BoxSize**3)

        # compute the mean mass per grid cell
        mean_M = np.sum(M,dtype=np.float64)/dims3

        # compute the mass within each grid cell
        delta = np.zeros((dims,dims,dims),dtype=np.float32)
        MASL.CICW(pos,delta,BoxSize,M); del pos
        print '%.6e should be equal to \n%.6e\n'\
            %(np.sum(M,dtype=np.float64),np.sum(delta,dtype=np.float64)); del M

        # compute the density constrast within each grid cell
        delta /= mean_M;  delta-=1.0
        print '%.3e < delta < %.3e\n'%(np.min(delta),np.max(delta))

        # compute the P(k)
        [k,Pk0,Pk2,Pk4,Nmodes] = Pk(delta,BoxSize,axis=axis,MAS='CIC',
                                    threads=cpus)

        # write P(k) to output file
        f_out = 'Pk_m_z='+z+'.dat'
        np.savetxt(f_out,np.transpose([k,Pk0,Pk2,Pk4,Nmodes]));  return none
    #####################################################################

    # set the label of the output files
    root_fout = {'0' :'GAS',  '01':'GCDM',  '02':'GNU',    '04':'Gstars',
                 '1' :'CDM',                '12':'CDMNU',  '14':'CDMStars',
                 '2' :'NU',                                '24':'NUStars',
                 '4' :'Stars'                                             }

    # define the arrays containing the positions and deltas and power spectra
    delta = [[],[],[],[]]   #array  containing the gas, CDM, NU and stars deltas
    Pk    = [[[],[],[],[]], #matrix containing the auto- and cross-power spectra
             [[],[],[],[]],
             [[],[],[],[]],
             [[],[],[],[]]]

    # dictionary among particle type and the index in the delta and Pk arrays
    # delta of stars (ptype=4) is delta[3] not delta[4]
    index_dict = {0:0, 1:1, 2:2, 4:3} 

    #####################################################################
    # do a loop over all particle types and compute the deltas
    for ptype in particle_type:
    
        # read particle positions in #Mpc/h
        pos = readsnap.read_block(snapshot_fname,"POS ",parttype=ptype)/1e3 

        # move particle positions to redshift-space
        if do_RSD:
            vel = readsnap.read_block(snapshot_fname,"VEL ",parttype=ptype)#km/s
            RSL.pos_redshift_space(pos,vel,BoxSize,Hubble,redshift,axis)
            del vel

        # find the index of the particle type in the delta array
        index = index_dict[ptype]

        # compute the deltas
        delta[index] = np.zeros((dims,dims,dims),dtype=np.float32)
        MASL.CIC(pos,delta[index],BoxSize)
        print '%.6e should be equal to \n%.6e\n'\
            %(len(pos),np.sum(delta[index],dtype=np.float64))

        # compute the density constrast within each grid cell
        delta[index] = delta[index]*dims3*1.0/len(pos)-1.0;  del pos
        print '%.3e < delta < %.3e\n'\
            %(np.min(delta[index]),np.max(delta[index]))
    #####################################################################

    #####################################################################
    # compute the auto-power spectrum when there is only one component
    if len(particle_type) == 1:

        ptype = particle_type[0];  index = index_dict[ptype]
        fout = 'Pk_'+root_fout[str(ptype)]+'_z='+z+'.dat'
        print '\nComputing the power spectrum of the particle type: ',ptype
        [k,Pk0,Pk2,Pk4,Nmodes] = Pk(delta,BoxSize,axis=axis,
                                    MAS='CIC',threads=cpus)
        np.savetxt(fout,np.transpose([k,Pk0,Pk2,Pk4,Nmodes]));  return None
    #####################################################################

    #####################################################################
    # if there are two or more particles compute auto- and cross-power spectra
    for i,ptype1 in enumerate(particle_type):
        for ptype2 in particle_type[i+1:]:

            # find the indexes of the particle types
            index1 = index_dict[ptype1];  index2 = index_dict[ptype2]

            # choose the name of the output files
            if do_RSD:  root_fname = 'Pk_RS_'+str(axis)+'_'
            else:       root_fname = 'Pk_'
            suffix = '_z='+z+'.dat'
            fout1  = root_fname + root_fout[str(ptype1)]             + suffix
            fout2  = root_fname + root_fout[str(ptype2)]             + suffix
            fout12 = root_fname + root_fout[str(ptype1)+str(ptype2)] + suffix

            # some verbose
            print '\nComputing the auto- and cross-power spectra of types: '\
                ,ptype1,'-',ptype2
            print 'saving results in:';  print fout1,'\n',fout2,'\n',fout12

            # This routine computes the auto- and cross-power spectra
            data = XPk(delta[index1],delta[index2],BoxSize,axis=axis,
                       MAS1='CIC',MAS2='CIC',threads=cpus)
                                                        
            k                  = data[0];   Nmodes             = data[10]
            Pk[index1][index2] = data[1];   Pk[index2][index1] = data[1]
            Pk[index1][index1] = data[4]
            Pk[index2][index2] = data[7]

            # save power spectra results in the output files
            np.savetxt(fout12,np.transpose([k,data[1],data[2],data[3],Nmodes]))
            np.savetxt(fout1, np.transpose([k,data[4],data[5],data[6],Nmodes]))
            np.savetxt(fout2, np.transpose([k,data[7],data[8],data[9],Nmodes]))
    #####################################################################

    #####################################################################
    # compute the power spectrum of the sum of all components
    print '\ncomputing P(k) of all components'

    # dictionary giving the value of Omega for each component
    Omega_dict = {0:Omega_g, 1:Omega_c, 2:Omega_n, 4:Omega_s}

    Pk_m = np.zeros(len(k),dtype=np.float64);  
    name = '_'+root_fout[str(particle_type[0])]
    Omega_tot = Omega_dict[particle_type[0]]
    for ptype in particle_type[1:]:  
        name += '+'+root_fout[str(ptype)]
        Omega_tot += Omega_dict[ptype]
    
    if do_RSD:  f_out_m = 'Pk'+name+'_RS_'+str(axis)+'_z='+z+'.dat'
    else:       f_out_m = 'Pk'+name+'_z='+z+'.dat'

    for ptype1 in particle_type:
        for ptype2 in particle_type:
        
            # find the indexes of the particle types
            index1 = index_dict[ptype1];  index2 = index_dict[ptype2]

            Pk_m += Omega_dict[ptype1]*Omega_dict[ptype2] * Pk[index1][index2]

    Pk_m /= Omega_tot**2
    np.savetxt(f_out_m,np.transpose([k,Pk_m])) #write results to output file
###############################################################################
###############################################################################
